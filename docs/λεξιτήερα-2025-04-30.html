
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ἑλληνική Λέξις (Θέμαe· Ἀθήναις)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; touch-action: manipulation; }
        .tile { width: 55px; height: 55px; border: 2px solid #d3d6da; display: flex; justify-content: center; align-items: center; font-size: 1.8rem; font-weight: bold; text-transform: uppercase; transition: transform 0.3s ease, background-color 0.5s ease, border-color 0.5s ease; box-sizing: border-box; }
        .tile.filled { border-color: #878a8c; }
        .tile.flip { transform: rotateX(180deg); }
        .correct { background-color: #6aaa64; border-color: #6aaa64; color: white; }
        .present { background-color: #c9b458; border-color: #c9b458; color: white; }
        .absent { background-color: #787c7e; border-color: #787c7e; color: white; }
        .key { height: 50px; min-width: 35px; padding: 0 8px; margin: 2px; border-radius: 4px; display: flex; justify-content: center; align-items: center; font-size: 1rem; font-weight: bold; background-color: #d3d6da; cursor: pointer; text-transform: uppercase; transition: background-color 0.2s ease; box-sizing: border-box; }
        .key:hover { background-color: #b0b3b8; }
        .key.wide {/* ... */ }
        .key[data-key="enter"] { font-size: 1.5rem; color: #10B981; font-weight: bold; }
        .key.disabled-key {
            opacity: 0.6; /* Dim the key */
            cursor: not-allowed; /* Show disabled cursor */
            pointer-events: none; /* Optional: Prevent click events directly via CSS */
        }
        .key.disabled-key:hover {
             background-color: #787c7e; /* Keep hover same as absent color */
        }
        button:disabled { /* ... */ }       
        button:disabled { background-color: #cccccc; color: #666666; cursor: not-allowed; opacity: 0.7; }
        @media (max-width: 640px) { .tile { width: 15vw; height: 15vw; max-width: 50px; max-height: 50px; font-size: 1.5rem; } .key { height: 45px; min-width: 7vw; padding: 0 4px; font-size: 0.9rem; margin: 1px; } .key.wide { min-width: 12vw; padding: 0 8px; } #keyboard { padding: 5px 1px; } .action-button { font-size: 0.9rem; padding: 6px 10px;} }
        @media (max-width: 380px) { .key { min-width: 9vw; padding: 0 2px; font-size: 0.8rem; } .key.wide { min-width: 15vw; padding: 0 5px; } }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); } 20%, 40%, 60%, 80% { transform: translateX(5px); } } .animate-shake { animation: shake 0.5s ease-in-out; }
        @keyframes dance { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-8px) scale(1.03); } } .animate-dance { animation: dance 0.5s ease-in-out; }
        @keyframes reveal { 0% { transform: scale(1); background-color: #eee; } 50% { transform: scale(1.1); background-color: #6aaa64; color: white; } 100% { transform: scale(1); background-color: #6aaa64; } } .tile.revealed { animation: reveal 0.6s ease-out; background-color: #6aaa64; border-color: #6aaa64; color: white; }
    </style>
</head>
<body class="bg-gray-100 flex flex-col items-center justify-between min-h-screen p-2 sm:p-4">

    <header class="text-center mb-4">
        <h1 class="text-3xl sm:text-4xl font-bold text-gray-800">Λεξιθήρα</h1>
        <p class="text-sm text-gray-600">Θέμαe· Ἀθήναις - 4 Γράμματα</p>
    </header>
    <div id="message-container" class="h-8 mb-2 text-center font-semibold text-red-600"><p id="message"></p></div>
    <div id="grid-container" class="grid grid-rows-6 gap-1 mb-4"></div>
    <div id="keyboard" class="mt-auto w-full max-w-xl p-1 bg-gray-200 rounded-md"></div>
    <div class="flex space-x-4 mt-4">
        <button id="reveal-letter" class="action-button px-4 py-2 bg-yellow-500 text-white font-semibold rounded-lg shadow-md hover:bg-yellow-600 focus:outline-none focus:ring-2 focus:ring-yellow-400 focus:ring-opacity-75 disabled:opacity-50 disabled:cursor-not-allowed">
            Δεῖξον γράμμα (1 χρῆσις)
        </button>
        <button id="play-again" class="action-button px-6 py-2 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-400 focus:ring-opacity-75 hidden">
            Παῖζε Πάλιν
        </button>
    </div>

    <script>
        const WORD_LENGTH = 4;
        const MAX_GUESSES = 6;
        const targetWord = "\u03b1\u03b3\u03c9\u03bd";
        const GREEK_WORDS = ["\u03bd\u03b1\u03bf\u03c2", "\u03b8\u03b5\u03bf\u03c2", "\u03b7\u03c1\u03c9\u03c2", "\u03c3\u03c4\u03bf\u03b1", "\u03b1\u03b3\u03c9\u03bd", "\u03b1\u03c3\u03c4\u03c5", "\u03b1\u03bd\u03b7\u03c1", "\u03b1\u03c1\u03c7\u03b7", "\u03bf\u03b4\u03bf\u03c2", "\u03bd\u03b9\u03ba\u03b7", "\u03c0\u03b1\u03b9\u03c2", "\u03c5\u03b4\u03c9\u03c1", "\u03b4\u03b9\u03ba\u03b7", "\u03b8\u03c5\u03c1\u03b1", "\u03ba\u03bf\u03c1\u03b7", "\u03bb\u03c5\u03c1\u03b1", "\u03c0\u03c5\u03bb\u03b7", "\u03c4\u03b1\u03c6\u03b7"];
        const themeName = "Ἀθήναις";

        const MSG_NOT_ENOUGH_LETTERS = "\u039b\u03b5\u03af\u03c0\u03b5\u03b9 \u03b3\u03c1\u03ac\u03bc\u03bc\u03b1\u03c4\u03b1!";
        const MSG_NOT_IN_WORD_LIST = "\u039f\u1f50\u03ba \u1f14\u03c3\u03c4\u03b9\u03bd \u1f10\u03bd \u03bb\u03cc\u03b3\u03bf\u03b9\u03c2!";
        const MSG_EXCELLENT = "\u1f0c\u03c1\u03b9\u03c3\u03c4\u03b1!";
        const MSG_REVEAL_USED = "\u1f2c\u03b4\u03b7 \u1f10\u03c7\u03c1\u03ae\u03c3\u03c9!";
        const MSG_NO_MORE_REVEAL = "\u039f\u1f50\u03ba \u1f14\u03c3\u03c4\u03b9 \u03b3\u03c1\u03ac\u03bc\u03bc\u03b1\u03c4\u03b1 \u03b4\u03b5\u1fd6\u03be\u03b1\u03b9!";
        const MSG_REVEALED = "\u1f18\u03b4\u03b5\u03af\u03c7\u03b8\u03b7:";
        const MSG_CANNOT_REVEAL_FULL = "\u039f\u1f50 \u03b4\u03cd\u03bd\u03b1\u03bc\u03b1\u03b9 \u03b4\u03b5\u1fd6\u03be\u03b1\u03b9 - \u03c0\u03bb\u1fc6\u03c1\u03b5\u03c2;";
        const MSG_ERROR_INIT = "\u03a3\u03c6\u03ac\u03bb\u03bc\u03b1 \u1f10\u03bd \u1f00\u03c1\u03c7\u1fc7.";
        const LABEL_WORD_WAS = "Ὁ λόγος ἦν:";

        const gridContainer = document.getElementById('grid-container');
        const keyboardContainer = document.getElementById('keyboard');
        const messageElement = document.getElementById('message');
        const playAgainButton = document.getElementById('play-again');
        const revealLetterButton = document.getElementById('reveal-letter');

        let currentRowIndex = 0; let currentColIndex = 0;
        let guesses = Array(MAX_GUESSES).fill(null).map(() => Array(WORD_LENGTH).fill(''));
        let isGameOver = false; let isProcessing = false;
        let keyStates = {}; let revealUsed = false;

        const keyboardLayout = [
            ['ε', 'ρ', 'τ', 'υ', 'θ', 'ι', 'ο', 'π'],
            ['α', 'σ', 'δ', 'φ', 'γ', 'η', 'ξ', 'κ', 'λ'],
            ['Enter', 'ζ', 'χ', 'ψ', 'ω', 'β', 'ν', 'μ', 'Backspace']
        ];

        function initializeGame() {
            currentRowIndex = 0; currentColIndex = 0;
            guesses = Array(MAX_GUESSES).fill(null).map(() => Array(WORD_LENGTH).fill(''));
            isGameOver = false; isProcessing = false; keyStates = {}; revealUsed = false;
            messageElement.textContent = '';
            playAgainButton.classList.add('hidden');
            revealLetterButton.disabled = false;
            revealLetterButton.classList.remove('opacity-50', 'cursor-not-allowed');
            console.log(`Theme: ${themeName}, Length: ${WORD_LENGTH}, Target: ${targetWord}`);
            createGrid(); createKeyboard(); addEventListeners();
        }

        function createGrid() {
            gridContainer.innerHTML = ''; gridContainer.style.maxWidth = `${WORD_LENGTH * 65}px`;
            for (let r = 0; r < MAX_GUESSES; r++) {
                const row = document.createElement('div'); row.classList.add('grid', `grid-cols-${WORD_LENGTH}`, 'gap-1'); row.dataset.row = r;
                for (let c = 0; c < WORD_LENGTH; c++) {
                    const tile = document.createElement('div'); tile.classList.add('tile'); tile.dataset.row = r; tile.dataset.col = c; row.appendChild(tile);
                } gridContainer.appendChild(row);
            }
        }

        function createKeyboard() {
            keyboardContainer.innerHTML = '';
            keyboardLayout.forEach(rowKeys => {
                const rowDiv = document.createElement('div'); rowDiv.classList.add('flex', 'justify-center', 'flex-wrap', 'mb-1');
                rowKeys.forEach(key => {
                    const button = document.createElement('button'); button.classList.add('key');
                    if (key === 'Enter') { button.textContent = '✔'; } else if (key === 'Backspace') { button.textContent = '⌫'; } else { button.textContent = key; }
                    button.dataset.key = key.toLowerCase();
                    if (key === 'Enter' || key === 'Backspace') { button.classList.add('wide'); }
                    const state = keyStates[key.toLowerCase()]; if (state) { button.classList.add(state); }
                    button.addEventListener('click', () => handleKeyPress(key.toLowerCase())); rowDiv.appendChild(button);
                }); keyboardContainer.appendChild(rowDiv);
            });
        }

        function addEventListeners() {
            document.removeEventListener('keydown', handlePhysicalKeyboard); document.addEventListener('keydown', handlePhysicalKeyboard);
            playAgainButton.removeEventListener('click', initializeGame); playAgainButton.addEventListener('click', initializeGame);
            revealLetterButton.removeEventListener('click', handleRevealLetter); revealLetterButton.addEventListener('click', handleRevealLetter);
        }

        function handlePhysicalKeyboard(event) {
                    if (isGameOver || isProcessing) { return; }
                    const key = event.key.toLowerCase();

                    const virtualKeyElement = keyboardContainer.querySelector(`[data-key="${key}"]`);
                    if (virtualKeyElement && virtualKeyElement.disabled) {
                        return;
                    }

                    if (key === 'enter') {
                        handleKeyPress('enter');
                    } else if (key === 'backspace') {
                        handleKeyPress('backspace');
                    } else if (key.length === 1 && 'αβγδεζηθικλμνξοπρστυφχψω'.includes(key)) {
                        handleKeyPress(key);
                    }
                }

        function handleKeyPress(key) {
            if (isGameOver || isProcessing) return;
            if (key === 'enter') { submitGuess(); } else if (key === 'backspace') { deleteLetter(); } else if ('αβγδεζηθικλμνξοπρστυφχψω'.includes(key)) { addLetter(key); }
        }

        function handleRevealLetter() { // Doubled braces
            if (isGameOver || isProcessing || revealUsed) { // Doubled braces
                if (revealUsed) { showMessage(MSG_REVEAL_USED, 1500); } // Doubled braces
                return;
            } // Doubled braces

            // --- Simplified Selection Logic ---
            let possibleHints = [];
            const targetLetters = targetWord.split(''); // Target word (e.g., ['ε', 'π', 'ο', 'ς'])

            for (let i = 0; i < WORD_LENGTH; i++) { // Iterate through each position
                const targetLetter = targetLetters[i]; // Target letter for this position (e.g., 'ς' at index 3)
                const isEmptyInCurrentGuess = !guesses[currentRowIndex][i]; // Is this slot empty now?

                // Check if this position 'i' was already correctly guessed in a previous row
                let previouslyCorrect = false;
                for (let r = 0; r < currentRowIndex; r++) { // Doubled braces
                    const prevTile = getTileElement(r, i);
                    if (prevTile && prevTile.classList.contains('correct')) { // Doubled braces
                        // Normalize comparison in case previous row showed σ for target ς
                        if (normalizeSigma(prevTile.textContent.toLowerCase()) === normalizeSigma(targetLetter)) { // Doubled braces
                           previouslyCorrect = true;
                           break;
                        } // Doubled braces
                    } // Doubled braces
                } // Doubled braces

                // If the slot is empty in the current guess AND wasn't correct previously at this position...
                if (isEmptyInCurrentGuess && !previouslyCorrect) { // Doubled braces
                    // ...then this is a potential hint. Store the letter and its correct index.
                    possibleHints.push({ letter: targetLetter, index: i });
                } // Doubled braces
            } // Doubled braces
            // --- End Simplified Selection Logic ---


            if (possibleHints.length === 0) { // Doubled braces
                // No suitable empty slots for letters that haven't been correctly placed yet.
                showMessage(MSG_NO_MORE_REVEAL, 1500); 
                return;
            } // Doubled braces

            // Choose a random hint from the valid possibilities
            const { letter, index } = possibleHints[Math.floor(Math.random() * possibleHints.length)];

            // --- Placement Logic (with else block fixed) ---
            const targetTile = getTileElement(currentRowIndex, index); 
            
            // Check if the target tile exists (it should) and is still empty 
            // (redundant check based on selection logic, but safe)
            if (targetTile && !guesses[currentRowIndex][index]) { // Doubled braces
                const letterToDisplay = letter.toUpperCase(); // Display revealed letter as uppercase
                guesses[currentRowIndex][index] = letter; // Store internal state as lowercase (might be 'ς')
                targetTile.textContent = letterToDisplay;
                targetTile.classList.add('filled', 'revealed'); // Mark as filled and add reveal animation class
                
                // Update keyboard state for the revealed letter (use normalized σ) to 'correct'
                updateKeyboard(normalizeSigma(letter), ['correct']); 

                revealUsed = true;
                revealLetterButton.disabled = true;
                revealLetterButton.classList.add('opacity-50', 'cursor-not-allowed');
                
                // Use JS concatenation for safety with Python f-strings
                showMessage(MSG_REVEALED + ' ' + letterToDisplay, 2000); 

                // Remove the visual animation class after it plays
                setTimeout(() => { // Doubled braces
                    const revealedTiles = gridContainer.querySelectorAll('.tile.revealed');
                    revealedTiles.forEach(t => t.classList.remove('revealed'));
                }, 600); // Doubled braces
            } else { // Doubled braces
                 // This block now runs if something unexpected happened 
                 // (e.g., the slot chosen was somehow filled between selection and placement).
                 // Avoid recursion. Just inform the user the hint failed this time.
                 showMessage(MSG_CANNOT_REVEAL_FULL, 1500); // Or a more specific error message
            } // Doubled braces
            // --- End Placement Logic ---

        } // Doubled braces

        function addLetter(letter) {
            if (currentColIndex < WORD_LENGTH && !isGameOver && !isProcessing) {
                guesses[currentRowIndex][currentColIndex] = letter; const tile = getTileElement(currentRowIndex, currentColIndex);
                if(tile) { tile.textContent = letter; tile.classList.add('filled'); } currentColIndex++;
            }
        }
        function deleteLetter() {
            if (currentColIndex > 0 && !isGameOver && !isProcessing) {
                currentColIndex--; guesses[currentRowIndex][currentColIndex] = ''; const tile = getTileElement(currentRowIndex, currentColIndex);
                 if(tile) { tile.textContent = ''; tile.classList.remove('filled'); }
            }
        }
       async function submitGuess() {
            if (currentColIndex !== WORD_LENGTH) { showMessage(MSG_NOT_ENOUGH_LETTERS); shakeRow(currentRowIndex); return; }
            const currentGuess = guesses[currentRowIndex].join('');
            isProcessing = true; revealLetterButton.disabled = true;
            const result = checkGuess(currentGuess, targetWord);
            await animateGuessResult(currentRowIndex, result); updateKeyboard(currentGuess, result);
            if (currentGuess === targetWord) {
                showMessage(MSG_EXCELLENT); isGameOver = true; playAgainButton.classList.remove('hidden'); revealLetterButton.disabled = true; danceRow(currentRowIndex);
            } else if (currentRowIndex === MAX_GUESSES - 1) {
                showMessage(`${LABEL_WORD_WAS} ${targetWord.toUpperCase()}`); isGameOver = true; playAgainButton.classList.remove('hidden'); revealLetterButton.disabled = true;
            } else {
                currentRowIndex++; currentColIndex = 0; if (!revealUsed) { revealLetterButton.disabled = false; }
            }
            isProcessing = false; if (isGameOver || revealUsed) { revealLetterButton.disabled = true; revealLetterButton.classList.add('opacity-50', 'cursor-not-allowed'); }
        }
        function normalizeSigma(word) { // Doubled braces
        // Replace all final sigma (ς) with medial sigma (σ)
        return word.replace(/ς/g, 'σ'); 
        } 
        
function checkGuess(guess, target) { // Doubled braces
        // Normalize both guess and target to use only medial sigma (σ)
        const normalizedGuess = normalizeSigma(guess);
        const normalizedTarget = normalizeSigma(target);

        const result = Array(WORD_LENGTH).fill('absent');
        // Perform comparisons using the normalized versions
        const targetLetters = normalizedTarget.split('');
        const guessLetters = normalizedGuess.split('');
        const letterCount = {}; // Doubled braces for JS object literal

        // Count letters in the normalized target
        targetLetters.forEach(letter => { // Doubled braces
            letterCount[letter] = (letterCount[letter] || 0) + 1;
        }); // Doubled braces

        // First pass: Check for correct letters (Green) using normalized versions
        for (let i = 0; i < WORD_LENGTH; i++) { // Doubled braces
            // Comparison is now σ vs σ (if original was σ or ς)
            if (guessLetters[i] === targetLetters[i]) { // Doubled braces
                result[i] = 'correct';
                // Decrement count using the normalized letter
                if (letterCount[guessLetters[i]]) { // Doubled braces
                    letterCount[guessLetters[i]]--;
                } // Doubled braces
            } // Doubled braces
        } // Doubled braces

        // Second pass: Check for present letters (Yellow) using normalized versions
        for (let i = 0; i < WORD_LENGTH; i++) { // Doubled braces
            if (result[i] !== 'correct') { // Doubled braces
                const currentLetter = guessLetters[i];
                // Check against remaining counts in letterCount (already reflects normalized target)
                if (targetLetters.includes(currentLetter) && letterCount[currentLetter] > 0) { // Doubled braces
                    result[i] = 'present';
                    letterCount[currentLetter]--; // Decrement count
                } // Doubled braces
            } // Doubled braces
        } // Doubled braces
        return result;
        } // Doubled braces

        function getTileElement(row, col) { return gridContainer.querySelector(`[data-row="${row}"][data-col="${col}"]`); }
        function getRowElement(row) { return gridContainer.querySelector(`[data-row="${row}"]`); }
        function showMessage(msg, duration = 2000) { messageElement.textContent = msg; if (duration > 0) { setTimeout(() => { if (messageElement.textContent === msg) { messageElement.textContent = ''; } }, duration); } }

        async function animateGuessResult(rowIndex, result) { // Doubled braces
                    // Using standard JS concatenation to avoid potential f-string/JS literal conflict
                    const rowTiles = gridContainer.querySelectorAll('[data-row="' + rowIndex + '"] .tile'); 
                    
                    if (!rowTiles) return;
                    for (let i = 0; i < WORD_LENGTH; i++) { // Doubled braces
                        const tile = rowTiles[i];
                        if (!tile) continue;
                        const state = result[i]; 

                        // Apply the flip animation ONLY if the state is 'absent'
                        if (state === 'absent') { // Doubled braces
                            tile.classList.add('flip');
                        } // Doubled braces
                        
                        // Wait for the first half of the potential flip animation (or just a delay)
                        await new Promise(resolve => setTimeout(resolve, 150));
                        
                        // Apply the state class (correct, present, absent) to change color/style
                        tile.classList.add(state);
                        
                        // Wait for the second half of the flip ONLY if it was actually flipping (state was 'absent')
                        if (state === 'absent') { // Doubled braces
                            await new Promise(resolve => setTimeout(resolve, 150));
                        } // Doubled braces
                    } // Doubled braces
                } // Doubled braces

        function updateKeyboard(guessOrLetter, resultOrState) { if (typeof guessOrLetter === 'string' && guessOrLetter.length === 1 && Array.isArray(resultOrState)) { const letter = guessOrLetter; const newState = resultOrState[0]; const currentKeyState = keyStates[letter]; let finalState = newState; if (currentKeyState === 'correct') { finalState = 'correct'; } else if (currentKeyState === 'present' && newState === 'absent') { finalState = 'present'; } keyStates[letter] = finalState; const keyElement = keyboardContainer.querySelector(`[data-key="${letter}"]`); if (keyElement) { keyElement.classList.remove('correct', 'present', 'absent'); keyElement.classList.add(finalState); } } else if (typeof guessOrLetter === 'string' && Array.isArray(resultOrState)) { const guessLetters = guessOrLetter.split(''); const result = resultOrState; for (let i = 0; i < WORD_LENGTH; i++) { const letter = guessLetters[i]; if (!letter) continue; const newState = result[i]; const currentKeyState = keyStates[letter]; let finalState = newState; if (currentKeyState === 'correct') { finalState = 'correct'; } else if (currentKeyState === 'present' && newState === 'absent') { finalState = 'present'; } keyStates[letter] = finalState; const keyElement = keyboardContainer.querySelector(`[data-key="${letter}"]`); if (keyElement) { keyElement.classList.remove('correct', 'present', 'absent'); keyElement.classList.add(finalState); } } } }
        // Slightly condensed updateKeyboard function (still multi-line for clarity)
 function updateKeyboard(guessOrLetter, resultOrState) {
            const processLetter = (letter, newState) => {
                const normalizedLetter = normalizeSigma(letter);
                const keyElement = keyboardContainer.querySelector(`[data-key="${normalizedLetter}"]`);
                if (!keyElement || keyElement.classList.contains('correct')) { return; }

                const currentKeyState = keyStates[normalizedLetter];
                let finalState = newState;

                if (currentKeyState === 'correct') {
                    finalState = 'correct';
                } else if (currentKeyState === 'present' && newState === 'absent') {
                    finalState = 'present';
                }

                if (finalState === 'absent' && currentKeyState !== 'correct' && currentKeyState !== 'present') {
                    keyElement.classList.add('disabled-key');
                    keyElement.disabled = true;
                }

                if (finalState !== 'absent' || currentKeyState !== 'present') {
                     keyElement.className = 'key' + (keyElement.classList.contains('wide') ? ' wide' : '') + ' ' + finalState + (keyElement.disabled ? ' disabled-key' : '');
                }

                keyStates[normalizedLetter] = finalState;
            };

            if (typeof guessOrLetter === 'string' && guessOrLetter.length === 1 && Array.isArray(resultOrState)) {
                processLetter(guessOrLetter, resultOrState[0]);
            } else if (typeof guessOrLetter === 'string' && Array.isArray(resultOrState)) {
                const guessLetters = guessOrLetter.split('');
                const result = resultOrState;
                for (let i = 0; i < WORD_LENGTH; i++) {
                    if (guessLetters[i]) { processLetter(guessLetters[i], result[i]); }
                }
            }
        }
        function shakeRow(rowIndex) { const rowElement = getRowElement(rowIndex); if (rowElement) { rowElement.classList.add('animate-shake'); setTimeout(() => { rowElement.classList.remove('animate-shake'); }, 500); } }
        function danceRow(rowIndex) { const rowTiles = gridContainer.querySelectorAll(`[data-row="${rowIndex}"] .tile`); if (!rowTiles) return; rowTiles.forEach((tile, index) => { if (!tile) return; setTimeout(() => { tile.classList.add('animate-dance'); }, index * 100); }); }

        if (typeof WORD_LENGTH === 'number' && typeof targetWord === 'string' && Array.isArray(GREEK_WORDS) && typeof themeName === 'string') { initializeGame(); }
        else { console.error("Game constants not properly defined."); showMessage(MSG_ERROR_INIT, 0); }
    </script>

</body>
</html>
